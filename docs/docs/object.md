# Object Methods

These are utility methods for handling objects.

## `pick(object, paths)`

Creates an object composed of the picked `object` properties.

### Usage

```ts
import { pick } from 'unfunt'

const object = { a: 1, b: '2', c: 3 }

pick(object, ['a', 'c'])
// => { a: 1, c: 3 }
```

### Arguments

1. `object` *(Object)*: The source object
2. `paths` *(Array)*: The property paths to pick

### Returns

*(Object)*: Returns the new object

## `pickBy(object, predicate)`

Creates an object composed of the `object` properties `predicate` returns truthy for.

### Usage

```ts
import { pickBy } from 'unfunt'

const object = { a: 1, b: '2', c: 3 }

pickBy(object, (value) => typeof value === 'number')
// => { a: 1, c: 3 }
```

### Arguments

1. `object` *(Object)*: The source object
2. `predicate` *(Function)*: The function invoked per property

### Returns

*(Object)*: Returns the new object

## `omit(object, paths)`

Creates an object composed of the own and inherited enumerable property paths of `object` that are not omitted.

### Usage

```ts
import { omit } from 'unfunt'

const object = { a: 1, b: '2', c: 3 }

omit(object, ['a', 'c'])
// => { b: '2' }
```

### Arguments

1. `object` *(Object)*: The source object
2. `paths` *(Array)*: The property paths to omit

### Returns

*(Object)*: Returns the new object

## `omitBy(object, predicate)`

Creates an object composed of the own and inherited enumerable string keyed properties of `object` that `predicate` doesn't return truthy for.

### Usage

```ts
import { omitBy } from 'unfunt'

const object = { a: 1, b: '2', c: 3 }

omitBy(object, (value) => typeof value === 'number')
// => { b: '2' }
```

### Arguments

1. `object` *(Object)*: The source object
2. `predicate` *(Function)*: The function invoked per property

### Returns

*(Object)*: Returns the new object

## `mapEntries(object, iteratee)`

Creates an object with the same keys as `object` and values generated by running each own enumerable string keyed property of `object` thru `iteratee`.

### Usage

```ts
import { mapEntries } from 'unfunt'

const object = { a: 1, b: 2 }

mapEntries(object, ([key, value]) => [key.toUpperCase(), value * 2])
// => { A: 2, B: 4 }
```

### Arguments

1. `object` *(Object)*: The object to iterate over
2. `iteratee` *(Function)*: The function invoked per iteration

### Returns

*(Object)*: Returns the new mapped object

## `forEachEntry(object, iteratee)`

Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property.

### Usage

```ts
import { forEachEntry } from 'unfunt'

forEachEntry({ a: 1, b: 2 }, ([key, value]) => {
  console.log(key, value)
})
// => Logs 'a 1' then 'b 2'
```

### Arguments

1. `object` *(Object)*: The object to iterate over
2. `iteratee` *(Function)*: The function invoked per iteration

### Returns

*(Object)*: Returns `object`

## `forOwn(object, iteratee)`

Iterates over own enumerable string keyed properties of an object and invokes `iteratee` for each property. The iteratee is invoked with three arguments: (value, key, object). Iteratee functions may exit iteration early by explicitly returning `false`.

### Usage

```ts
import { forOwn } from 'unfunt'

forOwn({ a: 1, b: 2 }, (value, key) => {
  console.log(key, value)
})
// => Logs 'a 1' then 'b 2'

// Exit early by returning false
forOwn({ a: 1, b: 2, c: 3 }, (value, key) => {
  console.log(key, value)
  if (key === 'b') return false
})
// => Logs 'a 1' then 'b 2'
```

### Arguments

1. `object` *(Object)*: The object to iterate over
2. `iteratee` *(Function)*: The function invoked per iteration. Receives `(value, key, object)` as arguments

### Returns

*(Object)*: Returns `object`